# 時系列データ確認機能の実装可能性についてのまとめ

## 調査日
2025年11月16日

## 1. 背景と目的

### 1.1 現状のアーキテクチャ
本ビューワーは当初、以下のような設計思想で開発されました：
- **配布方式**: 利用者がファイルをダウンロード
- **実行環境**: 各利用者がローカルでHTMLファイルを開いて使用
- **技術スタック**: 純粋なJavaScript（サーバーサイド処理なし）
- **データソース**: ユーザーが提供するCSVカタログファイルのみ

### 1.2 新たな要件
標準星を選択する際、より適切な判断を行うために以下のデータを確認したいという要望が生まれました：
- **ライトカーブ（光度曲線）**: 時系列での明るさの変動
- **目的**: 標準星としての適性判断（変光星を除外するなど）

この要件を実現するためには、サーバーを立てて利用者がアクセスする形式への移行を検討する必要があります。

---

## 2. 実装を検討する時系列データソース

### 2.1 NEOWISE ライトカーブ（優先度：高）

#### 概要
- **データソース**: NEOWISE（Near-Earth Object Wide-field Infrared Survey Explorer）
- **観測バンド**: W1（3.4μm）、W2（4.6μm）の赤外線
- **データ期間**: 2010年～現在（定期的なリリース）
- **カバレッジ**: 全天

#### 実装方式の検討

##### データ準備
1. **AllWISE IDによる照合**
   - 入力カタログに`AllWISE ID`列が含まれている場合に利用
   - サーバー側に保存されたNEOWISEデータとAllWISE IDで照合
   - 該当する天体のライトカーブを取得

2. **座標ベースの照合**
   - AllWISE IDがない場合、RA/Decで最近傍天体を検索
   - クロスマッチング半径：2-3秒角程度

##### サーバー側のデータ構造
```
neowise_data/
├── index.db              # 高速検索用インデックス（SQLite等）
├── lightcurves/
│   ├── J000001.23+012345.6.json
│   ├── J000002.45+012347.8.json
│   └── ...
```

各ライトカーブファイルの構造例（JSON形式）：
```json
{
  "allwise_id": "J000001.23+012345.6",
  "ra": 0.00513,
  "dec": 1.39600,
  "observations": [
    {
      "mjd": 55268.4523,
      "w1_mag": 12.345,
      "w1_err": 0.023,
      "w2_mag": 12.456,
      "w2_err": 0.034
    }
  ]
}
```

#### 技術的実装オプション

**オプションA: 静的ファイル配信 + JavaScript処理**
- **メリット**: シンプル、サーバーサイド処理不要
- **デメリット**: 大量のJSONファイルの管理が必要
- **実装難易度**: ★★☆☆☆

**オプションB: RESTful API + Pythonバックエンド**
- **メリット**: 柔軟性が高い、データベースでの高速検索
- **デメリット**: サーバーサイド開発が必要
- **実装難易度**: ★★★☆☆

**オプションC: WebAssembly + SQLite**
- **メリット**: クライアント側で完結、高速検索
- **デメリット**: 全データをダウンロードする必要あり
- **実装難易度**: ★★★★☆

##### 推奨実装方式
**オプションB（RESTful API + Pythonバックエンド）**を推奨

理由：
- データ量が大きい（全天のNEOWISEデータは数GB以上）
- サーバー側でフィルタリング・前処理が可能
- Pythonの天文ライブラリ（astropy等）を活用できる
- 将来的な拡張性が高い

#### APIエンドポイント設計例

```python
# 例1: AllWISE IDで検索
GET /api/lightcurve/neowise?allwise_id=J123456.78+901234.5

# 例2: 座標で検索
GET /api/lightcurve/neowise?ra=188.753&dec=-20.086&radius=3

# レスポンス例
{
  "status": "success",
  "data": {
    "allwise_id": "J123456.78+901234.5",
    "ra": 188.753,
    "dec": -20.086,
    "num_observations": 245,
    "observations": [
      {"mjd": 55268.45, "w1_mag": 12.34, "w1_err": 0.02, ...},
      ...
    ]
  }
}
```

---

### 2.2 ASASSN ライトカーブ（検討中）

#### 概要
- **データソース**: ASAS-SN（All-Sky Automated Survey for Supernovae）
- **観測バンド**: g、V（可視光）
- **データ期間**: 2011年～現在（継続観測中）
- **カバレッジ**: 全天
- **特徴**: 現在も観測が継続されているため、最新データが利用可能

#### 実装方式の検討

##### データ取得方法

**方法A: pyasassn ライブラリを使用**
```python
# pyasassnの使用例
from pyasassn import SkyPatrol

sp = SkyPatrol()
result = sp.query(ra=188.753, dec=-20.086, radius=3)  # 3秒角以内
lightcurve = result.lightcurve()
```

**メリット**:
- 最新のデータを都度取得可能
- サーバー側での事前データ準備が不要
- ASASSNの公式APIを利用するため信頼性が高い

**デメリット**:
- APIリクエストごとに外部サービスへのアクセスが必要
- レスポンス時間が長くなる可能性（数秒～数十秒）
- ASASSNサーバーの負荷を考慮する必要あり

**方法B: 定期的なデータミラーリング**
- ASASSNのデータを定期的にダウンロードしてサーバーに保存
- NEOWISEと同様の仕組みで配信

**メリット**:
- 高速なレスポンス
- ASASSNサーバーへの負荷軽減

**デメリット**:
- 大容量のストレージが必要
- 定期的な更新処理が必要
- データ量が膨大（全天で数TB規模）

##### 推奨実装方式
**方法A（pyasassnを使用した都度アクセス）**を推奨

理由：
- ASASSNは現在も観測継続中なので、最新データの取得が重要
- 1リクエストあたりのデータ量は小さい
- キャッシュ機構を導入すれば、同じ天体への重複リクエストを削減可能

#### キャッシュ戦略
```python
# Redis等を使用したキャッシュ例
import redis
import json

cache = redis.Redis()

def get_asassn_lightcurve(ra, dec, radius=3):
    cache_key = f"asassn:{ra:.6f}:{dec:.6f}:{radius}"
    
    # キャッシュを確認
    cached = cache.get(cache_key)
    if cached:
        return json.loads(cached)
    
    # ASASSNから取得
    from pyasassn import SkyPatrol
    sp = SkyPatrol()
    result = sp.query(ra=ra, dec=dec, radius=radius)
    
    # キャッシュに保存（24時間有効）
    cache.setex(cache_key, 86400, json.dumps(result))
    
    return result
```

#### APIエンドポイント設計例

```python
# 座標で検索（リアルタイム取得）
GET /api/lightcurve/asassn?ra=188.753&dec=-20.086&radius=3

# レスポンス例
{
  "status": "success",
  "data": {
    "ra": 188.753,
    "dec": -20.086,
    "num_observations": 1523,
    "bands": ["g", "V"],
    "observations": [
      {"mjd": 56789.12, "band": "V", "mag": 13.45, "err": 0.05},
      ...
    ]
  },
  "cached": false,
  "query_time_ms": 3420
}
```

---

## 3. サーバーアーキテクチャの検討

### 3.1 アーキテクチャの比較

#### 現行方式（静的配信）
```
[利用者のPC]
   └── index.html + app.js（ブラウザで実行）
       └── ローカルファイル（CSVカタログ）
```

**メリット**:
- サーバー管理不要
- オフラインで動作可能
- セキュリティリスクが低い

**デメリット**:
- 時系列データへのアクセス不可
- データ共有が困難
- 機能拡張に限界がある

#### 提案方式（サーバーベース）
```
[利用者のPC]
   └── Webブラウザ
       ↓ HTTPS
[Webサーバー]
   ├── フロントエンド（HTML/JS/CSS）
   └── バックエンドAPI（Python/Flask or FastAPI）
       ├── ローカルデータベース（NEOWISE）
       └── 外部API連携（ASASSN）
```

**メリット**:
- 時系列データへのアクセス可能
- Pythonの天文ライブラリを活用可能
- データの一元管理
- 機能拡張が容易

**デメリット**:
- サーバー管理が必要
- ネットワーク接続必須
- セキュリティ対策が必要

### 3.2 推奨技術スタック

#### バックエンド
```
- Python 3.9+
- FastAPI（高速、非同期対応、自動API文書生成）
- SQLite or PostgreSQL（NEOWISEデータ管理）
- Redis（キャッシュ）
```

FastAPIを選ぶ理由：
- 非同期処理対応（複数リクエストの並列処理）
- 自動的なAPI文書生成（Swagger UI）
- 型ヒントによる堅牢性
- 高速（Node.jsやGoに匹敵）

#### フロントエンド
```
- 現行のHTML/JavaScript構成を維持
- Chart.js or Plotly.js（ライトカーブ描画）
- Fetch API（バックエンドとの通信）
```

#### インフラ
```
- Docker（開発・本番環境の一致）
- Nginx（リバースプロキシ、静的ファイル配信）
- Let's Encrypt（HTTPS対応）
```

### 3.3 FastAPIでの実装例

```python
# backend/main.py
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import sqlite3
from typing import List, Optional
from pydantic import BaseModel

app = FastAPI(title="Web Standard Viewer API")

# CORS設定（フロントエンドからのアクセスを許可）
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

class Observation(BaseModel):
    mjd: float
    mag: float
    err: float
    band: str

class LightCurve(BaseModel):
    allwise_id: Optional[str]
    ra: float
    dec: float
    num_observations: int
    observations: List[Observation]

@app.get("/")
def read_root():
    return {"message": "Web Standard Viewer API", "version": "1.0"}

@app.get("/api/lightcurve/neowise", response_model=LightCurve)
def get_neowise_lightcurve(
    allwise_id: Optional[str] = None,
    ra: Optional[float] = None,
    dec: Optional[float] = None,
    radius: float = 3.0
):
    """
    NEOWISEライトカーブを取得
    
    Parameters:
    - allwise_id: AllWISE ID（例: J123456.78+901234.5）
    - ra: 赤経（度）
    - dec: 赤緯（度）
    - radius: 検索半径（秒角）
    """
    if not allwise_id and (ra is None or dec is None):
        raise HTTPException(status_code=400, detail="allwise_id or (ra, dec) required")
    
    # データベースから検索
    conn = sqlite3.connect("neowise.db")
    cursor = conn.cursor()
    
    if allwise_id:
        cursor.execute(
            "SELECT * FROM lightcurves WHERE allwise_id = ?",
            (allwise_id,)
        )
    else:
        # 座標による検索（簡略版）
        cursor.execute(
            """
            SELECT * FROM lightcurves 
            WHERE ABS(ra - ?) < ? AND ABS(dec - ?) < ?
            LIMIT 1
            """,
            (ra, radius/3600, dec, radius/3600)
        )
    
    result = cursor.fetchone()
    conn.close()
    
    if not result:
        raise HTTPException(status_code=404, detail="Light curve not found")
    
    # レスポンスを構築
    return LightCurve(
        allwise_id=result[0],
        ra=result[1],
        dec=result[2],
        num_observations=len(result[3]),
        observations=result[3]  # JSONとして保存されていると仮定
    )

@app.get("/api/lightcurve/asassn", response_model=LightCurve)
async def get_asassn_lightcurve(
    ra: float,
    dec: float,
    radius: float = 3.0
):
    """
    ASASSNライトカーブを取得（リアルタイム）
    
    Parameters:
    - ra: 赤経（度）
    - dec: 赤緯（度）
    - radius: 検索半径（秒角）
    """
    try:
        # キャッシュを確認（省略）
        
        # pyasassnで取得
        from pyasassn import SkyPatrol
        sp = SkyPatrol()
        result = sp.query(ra=ra, dec=dec, radius=radius)
        
        # データを整形
        observations = []
        for obs in result.data:
            observations.append(Observation(
                mjd=obs['mjd'],
                mag=obs['mag'],
                err=obs['err'],
                band=obs['band']
            ))
        
        return LightCurve(
            allwise_id=None,
            ra=ra,
            dec=dec,
            num_observations=len(observations),
            observations=observations
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

---

## 4. フロントエンド側の実装

### 4.1 ライトカーブ表示UI

#### 追加するUI要素
1. **星リストへの「ライトカーブ表示」ボタン追加**
   - 各星の行に「LC」ボタンを配置
   - クリックでモーダルウィンドウを表示

2. **ライトカーブモーダル**
   - グラフ表示エリア（Chart.js使用）
   - データソース選択（NEOWISE / ASASSN）
   - 統計情報表示（RMS、変動幅など）

### 4.2 JavaScript実装例

```javascript
// app.js に追加する関数

class SkyViewer {
    // ... 既存のコード ...

    async showLightCurve(star, source = 'neowise') {
        // モーダルを表示
        const modal = document.getElementById('lightcurve-modal');
        modal.style.display = 'block';
        
        // ローディング表示
        this.showStatus('Loading light curve...', 'info');
        
        try {
            let url;
            if (source === 'neowise') {
                // AllWISE IDがあればそれを使用、なければ座標
                if (star.allwise_id) {
                    url = `/api/lightcurve/neowise?allwise_id=${star.allwise_id}`;
                } else {
                    url = `/api/lightcurve/neowise?ra=${star.ra}&dec=${star.dec}`;
                }
            } else if (source === 'asassn') {
                url = `/api/lightcurve/asassn?ra=${star.ra}&dec=${star.dec}`;
            }
            
            // APIリクエスト
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            // ライトカーブをプロット
            this.plotLightCurve(data, source);
            
            this.showStatus('Light curve loaded', 'success');
        } catch (error) {
            console.error('Error loading light curve:', error);
            this.showStatus('Failed to load light curve', 'error');
        }
    }
    
    plotLightCurve(data, source) {
        const ctx = document.getElementById('lightcurve-chart').getContext('2d');
        
        // データを整形
        const mjds = data.observations.map(obs => obs.mjd);
        const mags = data.observations.map(obs => obs.mag);
        const errs = data.observations.map(obs => obs.err);
        
        // Chart.jsでプロット
        new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: `${source.toUpperCase()} Light Curve`,
                    data: mjds.map((mjd, i) => ({x: mjd, y: mags[i]})),
                    backgroundColor: 'rgba(75, 192, 192, 0.6)',
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'MJD (Modified Julian Date)'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Magnitude'
                        },
                        reverse: true  // 等級は小さいほど明るい
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: `Light Curve: RA=${data.ra.toFixed(4)}, Dec=${data.dec.toFixed(4)}`
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Mag: ${context.parsed.y.toFixed(3)} ± ${errs[context.dataIndex].toFixed(3)}`;
                            }
                        }
                    }
                }
            }
        });
    }
}
```

### 4.3 HTML追加要素

```html
<!-- index.html または viewer.html に追加 -->

<!-- ライトカーブ表示ボタン（星リストの各行に追加） -->
<button class="lc-button" onclick="skyViewer.showLightCurve(star, 'neowise')">
    LC
</button>

<!-- ライトカーブモーダル -->
<div id="lightcurve-modal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="document.getElementById('lightcurve-modal').style.display='none'">&times;</span>
        <h2>Light Curve</h2>
        
        <!-- データソース選択 -->
        <div class="lc-controls">
            <label>
                <input type="radio" name="lc-source" value="neowise" checked>
                NEOWISE
            </label>
            <label>
                <input type="radio" name="lc-source" value="asassn">
                ASASSN
            </label>
        </div>
        
        <!-- グラフ表示エリア -->
        <canvas id="lightcurve-chart" width="800" height="400"></canvas>
        
        <!-- 統計情報 -->
        <div id="lc-stats">
            <p><strong>Observations:</strong> <span id="lc-num-obs">-</span></p>
            <p><strong>RMS:</strong> <span id="lc-rms">-</span> mag</p>
            <p><strong>Range:</strong> <span id="lc-range">-</span> mag</p>
        </div>
    </div>
</div>

<!-- Chart.js読み込み -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
```

---

## 5. データベース設計

### 5.1 NEOWISEデータベーススキーマ

```sql
-- SQLiteスキーマ例

CREATE TABLE lightcurves (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    allwise_id TEXT UNIQUE NOT NULL,
    ra REAL NOT NULL,
    dec REAL NOT NULL,
    num_observations INTEGER,
    data_json TEXT,  -- 観測データをJSON形式で保存
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 座標検索用のインデックス
CREATE INDEX idx_ra_dec ON lightcurves(ra, dec);
CREATE INDEX idx_allwise_id ON lightcurves(allwise_id);

-- R-Treeインデックス（空間検索の高速化）
CREATE VIRTUAL TABLE lightcurves_spatial USING rtree(
    id,
    min_ra, max_ra,
    min_dec, max_dec
);
```

### 5.2 データ投入スクリプト例

```python
# scripts/populate_neowise_db.py
import sqlite3
import json
from astropy.io import fits
from astropy.coordinates import SkyCoord
import astropy.units as u

def populate_database(neowise_fits_dir, db_path):
    """
    NEOWISEのFITSファイルからデータベースを構築
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # FITSファイルを読み込み
    for fits_file in neowise_fits_dir.glob("*.fits"):
        with fits.open(fits_file) as hdul:
            data = hdul[1].data
            
            for source in data:
                allwise_id = source['designation']
                ra = source['ra']
                dec = source['dec']
                
                # 時系列データを抽出
                observations = []
                for i in range(len(source['mjd'])):
                    if source['w1mag'][i] > 0:  # 有効なデータのみ
                        observations.append({
                            'mjd': source['mjd'][i],
                            'w1_mag': source['w1mag'][i],
                            'w1_err': source['w1sigm'][i],
                            'w2_mag': source['w2mag'][i],
                            'w2_err': source['w2sigm'][i]
                        })
                
                if len(observations) > 0:
                    # データベースに挿入
                    cursor.execute(
                        """
                        INSERT OR REPLACE INTO lightcurves 
                        (allwise_id, ra, dec, num_observations, data_json)
                        VALUES (?, ?, ?, ?, ?)
                        """,
                        (allwise_id, ra, dec, len(observations), json.dumps(observations))
                    )
    
    conn.commit()
    conn.close()

if __name__ == "__main__":
    populate_database("/path/to/neowise/data", "neowise.db")
```

---

## 6. デプロイメント戦略

### 6.1 Dockerによるコンテナ化

```dockerfile
# Dockerfile
FROM python:3.9-slim

WORKDIR /app

# 依存関係をインストール
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# アプリケーションファイルをコピー
COPY backend/ ./backend/
COPY frontend/ ./frontend/
COPY neowise.db ./

# FastAPIを起動
CMD ["uvicorn", "backend.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - ./neowise.db:/app/neowise.db
      - ./backend:/app/backend
    environment:
      - REDIS_URL=redis://redis:6379
    depends_on:
      - redis
  
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
  
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./frontend:/usr/share/nginx/html
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - api
```

### 6.2 本番環境構成

```
                    Internet
                       |
                    [ロードバランサー]
                       |
                    [Nginx]
                    /     \
            [静的ファイル]  [/api/*]
                 |            |
            [HTML/JS/CSS]  [FastAPI]
                              |
                        [Redis Cache]
                              |
                        [SQLite/PostgreSQL]
```

---

## 7. セキュリティ対策

### 7.1 必要なセキュリティ対策

1. **HTTPS対応**
   - Let's Encryptで無料SSL証明書取得
   - HTTP通信の強制リダイレクト

2. **レート制限**
   ```python
   from slowapi import Limiter
   from slowapi.util import get_remote_address
   
   limiter = Limiter(key_func=get_remote_address)
   app.state.limiter = limiter
   
   @app.get("/api/lightcurve/asassn")
   @limiter.limit("10/minute")  # 1分間に10リクエストまで
   async def get_asassn_lightcurve(request: Request, ...):
       ...
   ```

3. **入力検証**
   - Pydanticモデルによる型検証
   - 座標範囲のチェック（RA: 0-360, Dec: -90~90）
   - SQLインジェクション対策（パラメータ化クエリ）

4. **CORS設定**
   - 本番環境では特定のオリジンのみ許可
   ```python
   app.add_middleware(
       CORSMiddleware,
       allow_origins=["https://yourdomain.com"],
       allow_methods=["GET"],
       allow_headers=["*"],
   )
   ```

5. **エラーハンドリング**
   - 詳細なエラーメッセージを隠蔽
   - ログ記録による監視

---

## 8. パフォーマンス最適化

### 8.1 データベース最適化

1. **インデックスの活用**
   - AllWISE ID、座標（RA, Dec）にインデックス
   - R-Treeによる空間検索の高速化

2. **クエリの最適化**
   ```python
   # 効率的な近傍検索
   cursor.execute(
       """
       SELECT * FROM lightcurves
       WHERE ra BETWEEN ? AND ?
       AND dec BETWEEN ? AND ?
       ORDER BY 
           (ra - ?)*(ra - ?) + (dec - ?)*(dec - ?) ASC
       LIMIT 1
       """,
       (ra - radius/3600, ra + radius/3600,
        dec - radius/3600, dec + radius/3600,
        ra, ra, dec, dec)
   )
   ```

3. **データ圧縮**
   - JSON圧縮（gzip）
   - 観測データの間引き（高頻度観測の場合）

### 8.2 キャッシュ戦略

1. **Redisによるキャッシュ**
   - よく検索される天体のライトカーブをキャッシュ
   - TTL: 24時間（NEOWISE）、1時間（ASASSN）

2. **ブラウザキャッシュ**
   - 静的ファイル（HTML/JS/CSS）のキャッシュ
   - Cache-Controlヘッダーの設定

3. **CDN活用**
   - 静的コンテンツをCDNで配信
   - グローバルな高速アクセス

---

## 9. 実装ロードマップ

### フェーズ1: NEOWISE実装（優先）

**期間**: 2-3ヶ月

**タスク**:
1. NEOWISEデータの収集とデータベース構築（4週間）
   - データダウンロード
   - 前処理・クリーニング
   - SQLiteデータベース構築

2. バックエンドAPI開発（3週間）
   - FastAPIセットアップ
   - NEOWISE APIエンドポイント実装
   - ユニットテスト作成

3. フロントエンド実装（2週間）
   - ライトカーブモーダルUI作成
   - Chart.js統合
   - APIとの連携

4. 統合テスト・デプロイ（2週間）
   - E2Eテスト
   - パフォーマンステスト
   - 本番環境デプロイ

**マイルストーン**:
- [ ] NEOWISEデータベース完成
- [ ] APIエンドポイント実装完了
- [ ] フロントエンド実装完了
- [ ] 本番環境リリース

### フェーズ2: ASASSN実装（検討）

**期間**: 1-2ヶ月

**タスク**:
1. pyasassn統合検証（1週間）
   - ライブラリのテスト
   - レスポンス時間の測定
   - エラーハンドリング

2. バックエンドAPI拡張（2週間）
   - ASASSN APIエンドポイント実装
   - キャッシュ機構の実装
   - レート制限の実装

3. フロントエンド拡張（1週間）
   - データソース切り替えUI
   - ASASSNデータの表示

4. テスト・デプロイ（1週間）

**前提条件**:
- フェーズ1の完了
- ASASSNサーバーの安定性確認
- pyasassnライブラリの動作検証

---

## 10. コストとリソース見積もり

### 10.1 開発コスト

| 項目 | 工数 | 備考 |
|-----|------|------|
| NEOWISEデータ準備 | 4週間 | データダウンロード、前処理 |
| バックエンド開発 | 3週間 | FastAPI、DB設計 |
| フロントエンド開発 | 2週間 | UI実装、Chart.js統合 |
| テスト・デプロイ | 2週間 | 統合テスト、本番環境構築 |
| ASASSN統合 | 4週間 | pyasassn、キャッシュ |
| **合計** | **15週間** | 約4ヶ月 |

### 10.2 運用コスト（月額）

| 項目 | 費用 | 備考 |
|-----|------|------|
| サーバー（VPS） | $20-50 | 2-4GB RAM、50-100GB SSD |
| ストレージ追加 | $5-20 | NEOWISEデータ用（100-500GB） |
| Redis | $0-10 | 無料プランで十分 |
| SSL証明書 | $0 | Let's Encrypt無料 |
| バックアップ | $5-10 | 週次バックアップ |
| **合計** | **$30-90** | サーバー規模により変動 |

推奨サーバースペック:
- CPU: 2コア以上
- RAM: 4GB以上
- ストレージ: 200GB以上（SSD推奨）
- ネットワーク: 1TB/月以上

### 10.3 スケーラビリティ

**小規模運用（~100ユーザー）**:
- 単一サーバーで十分
- SQLite使用
- 月額$30-50程度

**中規模運用（100-1000ユーザー）**:
- PostgreSQL移行
- Redis導入
- ロードバランサー検討
- 月額$100-200程度

**大規模運用（1000+ユーザー）**:
- マイクロサービス化
- CDN導入
- 複数サーバーのクラスタリング
- 月額$500+

---

## 11. リスクと対策

### 11.1 技術的リスク

| リスク | 影響 | 対策 |
|--------|------|------|
| データ量が大きすぎる | ストレージ不足 | データの間引き、圧縮 |
| ASASSNレスポンスが遅い | UX低下 | キャッシュ、タイムアウト設定 |
| サーバー障害 | サービス停止 | 冗長化、バックアップ |
| セキュリティ脆弱性 | データ漏洩 | 定期的な脆弱性診断 |

### 11.2 運用リスク

| リスク | 影響 | 対策 |
|--------|------|------|
| サーバー管理の負担 | 運用コスト増 | 自動化スクリプト、監視ツール |
| データの古さ | 情報の不正確性 | 定期的なデータ更新 |
| 利用者増によるコスト増 | 予算超過 | スケーリング計画、利用制限 |

---

## 12. 結論と推奨事項

### 12.1 実装可能性の評価

| 項目 | 評価 | 備考 |
|-----|------|------|
| **技術的実現性** | ★★★★☆ | 高い。必要な技術はすべて利用可能 |
| **NEOWISE統合** | ★★★★★ | 非常に高い。データ準備とAPI実装のみ |
| **ASASSN統合** | ★★★☆☆ | 中程度。外部APIの安定性に依存 |
| **開発難易度** | ★★★☆☆ | 中程度。Pythonの天文ライブラリ知識が必要 |
| **運用難易度** | ★★★☆☆ | 中程度。サーバー管理とメンテナンスが必要 |
| **コスト効率** | ★★★★☆ | 高い。月額$30-90で運用可能 |

### 12.2 推奨実装アプローチ

#### 推奨方式: **段階的実装**

**ステップ1: 最小機能プロトタイプ（1ヶ月）**
- FastAPI + SQLiteでシンプルなAPI構築
- 少数の天体（100個程度）でテスト
- フロントエンドに最小限のライトカーブ表示機能を追加
- **目的**: 技術検証、UI/UXの確認

**ステップ2: NEOWISE本格実装（2ヶ月）**
- 全天のNEOWISEデータをデータベース化
- 本番環境のセットアップ（Docker + Nginx）
- パフォーマンステスト、最適化
- **目的**: 実用レベルのサービス提供

**ステップ3: ASASSN統合（1-2ヶ月）**
- pyasassnの統合と検証
- キャッシュ戦略の実装
- エラーハンドリングの強化
- **目的**: データソースの多様化

### 12.3 重要な留意点

1. **サーバーベースへの移行は不可逆的**
   - 一度移行すると、オフライン動作ができなくなる
   - ローカル版とサーバー版の両方を維持する選択肢も検討すべき

2. **データ更新の自動化が必須**
   - NEOWISEは年に数回新しいデータがリリースされる
   - 自動更新スクリプトの開発が必要

3. **利用者数の想定**
   - 小規模（~50人）なら簡易的な実装で十分
   - 大規模（100人以上）なら本格的なインフラ投資が必要

4. **代替案の検討**
   - 既存のサービス（IRSA、VizieR等）へのリンクも併用
   - ライトカーブの詳細分析は外部ツールに委ねる選択肢も

### 12.4 次のアクション

1. **ステークホルダーとの調整**
   - 利用者数の見積もり
   - 予算の確保
   - サーバー管理の責任者決定

2. **技術検証**
   - NEOWISEデータのサンプルをダウンロード
   - プロトタイプの開発（1-2週間）
   - pyasassnの動作確認

3. **実装判断**
   - プロトタイプの評価
   - コスト・ベネフィット分析
   - 本格開発の承認

---

## 13. 参考資料

### 13.1 データソース

- **NEOWISE**: https://irsa.ipac.caltech.edu/Missions/wise.html
- **ASAS-SN**: https://asas-sn.osu.edu/
- **AllWISE**: https://wise2.ipac.caltech.edu/docs/release/allwise/

### 13.2 ツール・ライブラリ

- **FastAPI**: https://fastapi.tiangolo.com/
- **pyasassn**: https://github.com/asassn/pyasassn
- **astropy**: https://www.astropy.org/
- **Chart.js**: https://www.chartjs.org/
- **SQLite**: https://www.sqlite.org/

### 13.3 類似プロジェクト

- **Aladin Lite**: 本プロジェクトで使用中
- **IRSA Viewer**: NASAのマルチスペクトルビューワー
- **ESO Archive**: ESOの天文データアーカイブ
- **MAST Portal**: STScIのデータポータル

---

## 14. まとめ

### 実装可能性: **高い**

本調査の結果、時系列データ確認機能の実装は**技術的に十分実現可能**であることが確認できました。

**主な結論**:

1. ✅ **NEOWISE統合**: 実装は容易。優先的に実装すべき
   - データ準備とAPI実装で2-3ヶ月
   - 月額$30-50の低コストで運用可能

2. ⚠️ **ASASSN統合**: 実装可能だが、外部依存が課題
   - pyasassnの動作検証が必要
   - キャッシュ戦略で性能問題は解決可能
   - NEOWISEの後に実装を推奨

3. 🚀 **推奨アプローチ**: 段階的実装
   - プロトタイプ → NEOWISE → ASASSN
   - リスクを最小化しながら機能拡張

4. 💰 **コスト**: 妥当
   - 開発: 3-4ヶ月
   - 運用: 月額$30-90
   - 小規模利用なら低コストで実現可能

5. ⚙️ **技術選択**: Python + FastAPI
   - 天文ライブラリとの親和性が高い
   - 高速で非同期処理に対応
   - 開発効率が良い

**最終推奨**:

まずはNEOWISEデータによるライトカーブ表示機能の実装を**強く推奨**します。技術的にも運用的にも実現可能であり、標準星選択の質を大幅に向上させることができます。

ASASSNについては、NEOWISEの実装後に、実際の利用状況を見ながら追加実装を検討することが賢明です。

---

**文書作成日**: 2025年11月16日  
**作成者**: GitHub Copilot Agent  
**バージョン**: 1.0
